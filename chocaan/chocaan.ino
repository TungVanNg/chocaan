/*
 * H·ªÜ TH·ªêNG CHO C√Å ƒÇN TH√îNG MINH - PHI√äN B·∫¢N T·ªêI ∆ØU SERVO + TI·∫æT KI·ªÜM BLYNK QUOTA
 * S·ª≠ d·ª•ng: ESP32 + Servo SG90 360¬∞ + HC-SR04 + Blynk + H·∫πn gi·ªù t·ª± ƒë·ªông
 * T√°c gi·∫£: TUNG VAN
 * Ng√†y: 2025
 * 
 * ‚ú® T√çNH NƒÇNG M·ªöI:
 * - Servo quay nhanh v√† ch√≠nh x√°c v·ªã tr√≠
 * - ƒêi·ªÅu khi·ªÉn l∆∞·ª£ng th·ª©c ƒÉn t·ªëi ∆∞u
 * - C√≥ th·ªÉ ƒëi·ªÅu ch·ªânh g√≥c quay v√† th·ªùi gian
 * - TI·∫æT KI·ªÜM T·ªêI ƒêA BLYNK QUOTA MESSAGES
 */

// ======= TH√îNG TIN BLYNK (PH·∫¢I KHAI B√ÅO TR∆Ø·ªöC KHI INCLUDE) =======
#define BLYNK_TEMPLATE_ID "TMPL6nmuVb1ro"
#define BLYNK_TEMPLATE_NAME "chocaan"
#define BLYNK_AUTH_TOKEN "B6kvGj0s7VeVwEoLMr04InI3voHwJu1v"

// ======= TH∆Ø VI·ªÜN C·∫¶N THI·∫æT =======
#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include <ESP32Servo.h>
#include <time.h>

// ======= TH√îNG TIN WIFI =======
char ssid[] = "Homie 10/5";     // T√™n WiFi
char pass[] = "motdentam"; // M·∫≠t kh·∫©u WiFi

// ======= C·∫§U H√åNH TH·ªúI GIAN =======
#define GMT_OFFSET_SEC 7*3600    // UTC+7 (Vi·ªát Nam)
#define DAYLIGHT_OFFSET_SEC 0    // Kh√¥ng c√≥ gi·ªù m√πa h√®
const char* ntpServer = "pool.ntp.org";

// ======= ƒê·ªäNH NGHƒ®A CH√ÇN K·∫æT N·ªêI =======
#define SERVO_PIN 23    // Servo 360¬∞ n·ªëi v·ªõi GPIO 23
#define TRIG_PIN 5      // HC-SR04 TRIG n·ªëi v·ªõi GPIO 5
#define ECHO_PIN 18     // HC-SR04 ECHO n·ªëi v·ªõi GPIO 18

// ======= ƒê·ªäNH NGHƒ®A VIRTUAL PIN BLYNK =======
#define V_AUTO_MODE 0    // V0: Switch b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô c·∫£m bi·∫øn t·ª± ƒë·ªông
#define V_DISTANCE 1     // V1: Hi·ªÉn th·ªã kho·∫£ng c√°ch
#define V_MANUAL_FEED 2  // V2: Button cho ƒÉn th·ªß c√¥ng
#define V_SCHEDULE_MODE 3 // V3: Switch b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô h·∫πn gi·ªù
#define V_MORNING_TIME 4  // V4: Time Input cho bu·ªïi s√°ng
#define V_EVENING_TIME 5  // V5: Time Input cho bu·ªïi chi·ªÅu
#define V_CURRENT_TIME 6  // V6: Hi·ªÉn th·ªã th·ªùi gian hi·ªán t·∫°i
#define V_LAST_FEED 7     // V7: Hi·ªÉn th·ªã l·∫ßn cho ƒÉn cu·ªëi
#define V_FEED_AMOUNT 8   // V8: Slider ƒëi·ªÅu ch·ªânh l∆∞·ª£ng th·ª©c ƒÉn (200-1000ms)
#define V_SERVO_SPEED 9   // V9: Slider ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô servo (90-180)

// ======= C·∫§U H√åNH SERVO T·ªêI ∆ØU =======
#define SERVO_STOP_SPEED 90      // T·ªëc ƒë·ªô d·ª´ng servo
#define SERVO_MIN_SPEED 95       // T·ªëc ƒë·ªô quay ch·∫≠m nh·∫•t
#define SERVO_MAX_SPEED 180      // T·ªëc ƒë·ªô quay nhanh nh·∫•t
#define SERVO_DEFAULT_SPEED 150  // T·ªëc ƒë·ªô m·∫∑c ƒë·ªãnh (nhanh)

// C·∫•u h√¨nh th·ªùi gian cho ƒÉn
#define FEED_TIME_MIN 200        // Th·ªùi gian cho ƒÉn t·ªëi thi·ªÉu (ms)
#define FEED_TIME_MAX 2000       // Th·ªùi gian cho ƒÉn t·ªëi ƒëa (ms)
#define FEED_TIME_DEFAULT 600    // Th·ªùi gian cho ƒÉn m·∫∑c ƒë·ªãnh (ms)

// ======= C·∫§U H√åNH TI·∫æT KI·ªÜM BLYNK QUOTA =======
#define DISTANCE_UPDATE_INTERVAL 5000    // G·ª≠i kho·∫£ng c√°ch m·ªói 5 gi√¢y (thay v√¨ m·ªói 100ms)
#define TIME_UPDATE_INTERVAL 300000      // G·ª≠i th·ªùi gian m·ªói 5 ph√∫t (thay v√¨ m·ªói ph√∫t)
#define DISTANCE_CHANGE_THRESHOLD 2.0    // Ch·ªâ g·ª≠i khi kho·∫£ng c√°ch thay ƒë·ªïi >2cm
#define MAX_DISTANCE_FOR_DISPLAY 50.0    // Kh√¥ng g·ª≠i n·∫øu kho·∫£ng c√°ch >50cm (tr√°nh nhi·ªÖu)

// ======= KH·ªûI T·∫†O ƒê·ªêI T∆Ø·ª¢NG =======
Servo feedServo;

// ======= BI·∫æN TO√ÄN C·ª§C =======
bool autoMode = false;           // Ch·∫ø ƒë·ªô c·∫£m bi·∫øn t·ª± ƒë·ªông (m·∫∑c ƒë·ªãnh t·∫Øt)
bool scheduleMode = false;       // Ch·∫ø ƒë·ªô h·∫πn gi·ªù (m·∫∑c ƒë·ªãnh t·∫Øt)
unsigned long lastAutoFeedTime = 0;  // Th·ªùi gian l·∫ßn cho ƒÉn t·ª± ƒë·ªông cu·ªëi (ch·ªâ √°p d·ª•ng cho c·∫£m bi·∫øn)
const unsigned long SENSOR_FEED_DELAY = 10000; // 10 gi√¢y delay cho ch·∫ø ƒë·ªô c·∫£m bi·∫øn
const float TRIGGER_DISTANCE = 5.0;     // Kho·∫£ng c√°ch k√≠ch ho·∫°t (5cm)

// Bi·∫øn h·∫πn gi·ªù
int morningHour = 8, morningMinute = 0;    // M·∫∑c ƒë·ªãnh 8:00 s√°ng
int eveningHour = 17, eveningMinute = 0;   // M·∫∑c ƒë·ªãnh 17:00 chi·ªÅu
bool morningFed = false, eveningFed = false; // C·ªù ƒë√£ cho ƒÉn trong ng√†y
int lastFeedDay = -1;                      // Ng√†y cho ƒÉn cu·ªëi ƒë·ªÉ reset c·ªù

// Bi·∫øn ƒëi·ªÅu khi·ªÉn servo t·ªëi ∆∞u
int servoSpeed = SERVO_DEFAULT_SPEED;      // T·ªëc ƒë·ªô servo c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh
int feedDuration = FEED_TIME_DEFAULT;      // Th·ªùi gian cho ƒÉn c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh

// ======= BI·∫æN TI·∫æT KI·ªÜM BLYNK QUOTA =======
float lastSentDistance = -1;              // Kho·∫£ng c√°ch g·ª≠i l·∫ßn cu·ªëi
unsigned long lastDistanceUpdate = 0;     // Th·ªùi gian c·∫≠p nh·∫≠t kho·∫£ng c√°ch cu·ªëi
unsigned long lastTimeUpdate = 0;         // Th·ªùi gian c·∫≠p nh·∫≠t th·ªùi gian cu·ªëi
bool blynkDataSent = false;               // C·ªù ƒë√£ g·ª≠i d·ªØ li·ªáu kh·ªüi t·∫°o

// ======= H√ÄM ƒêO KHO·∫¢NG C√ÅCH HC-SR04 =======
float measureDistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  
  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  float distance = (duration * 0.034) / 2;
  
  if (duration == 0) {
    distance = 999;
  }
  
  return distance;
}

// ======= H√ÄM G·ª¨I KHO·∫¢NG C√ÅCH TH√îNG MINH (TI·∫æT KI·ªÜM QUOTA) =======
void smartSendDistance(float distance) {
  unsigned long currentTime = millis();
  
  // Ch·ªâ g·ª≠i n·∫øu:
  // 1. ƒê√£ ƒë·ªß th·ªùi gian delay (5 gi√¢y)
  // 2. Kho·∫£ng c√°ch thay ƒë·ªïi ƒë√°ng k·ªÉ (>2cm)
  // 3. Kho·∫£ng c√°ch trong ph·∫°m vi h·ª£p l√Ω (<50cm ƒë·ªÉ tr√°nh nhi·ªÖu)
  
  if (currentTime - lastDistanceUpdate >= DISTANCE_UPDATE_INTERVAL) {
    if (distance <= MAX_DISTANCE_FOR_DISPLAY && 
        (lastSentDistance == -1 || abs(distance - lastSentDistance) >= DISTANCE_CHANGE_THRESHOLD)) {
      
      Blynk.virtualWrite(V_DISTANCE, distance);
      lastSentDistance = distance;
      lastDistanceUpdate = currentTime;
      
      Serial.printf("üì° G·ª≠i kho·∫£ng c√°ch: %.1fcm\n", distance);
    } else if (distance > MAX_DISTANCE_FOR_DISPLAY && lastSentDistance <= MAX_DISTANCE_FOR_DISPLAY) {
      // G·ª≠i m·ªôt l·∫ßn khi v·∫≠t ra kh·ªèi ph·∫°m vi
      Blynk.virtualWrite(V_DISTANCE, 999);
      lastSentDistance = 999;
      lastDistanceUpdate = currentTime;
      Serial.println("üì° G·ª≠i: Kh√¥ng ph√°t hi·ªán v·∫≠t th·ªÉ");
    }
  }
}

// ======= H√ÄM CHO C√Å ƒÇN T·ªêI ∆ØU (N√ÇNG C·∫§P HO√ÄN TO√ÄN) =======
void feedFish(String feedType = "MANUAL") {
  Serial.println("üêü B·∫ÆT ƒê·∫¶U CHO C√Å ƒÇN - " + feedType);
  Serial.printf("‚öôÔ∏è C·∫•u h√¨nh: T·ªëc ƒë·ªô=%d, Th·ªùi gian=%dms\n", servoSpeed, feedDuration);
  
  // B∆∞·ªõc 1: ƒê·∫£m b·∫£o servo d·ª´ng ho√†n to√†n tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu
  feedServo.write(SERVO_STOP_SPEED);
  delay(200); // Ch·ªù servo ·ªïn ƒë·ªãnh
  
  // B∆∞·ªõc 2: Quay v·ªõi t·ªëc ƒë·ªô cao ƒë·ªÉ m·ªü l·ªó cho ƒÉn
  Serial.println("üîÑ ƒêang m·ªü l·ªó cho ƒÉn...");
  feedServo.write(servoSpeed); // Quay nhanh
  delay(feedDuration);         // Th·ªùi gian cho ƒÉn c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh
  
  // B∆∞·ªõc 3: D·ª´ng servo ngay l·∫≠p t·ª©c
  feedServo.write(SERVO_STOP_SPEED);
  delay(100); // Ch·ªù servo d·ª´ng ho√†n to√†n
  
  // B∆∞·ªõc 4: Tinh ch·ªânh v·ªã tr√≠ l·ªó cho ƒÉn (quay ng∆∞·ª£c l·∫°i m·ªôt ch√∫t)
  // ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o l·ªó quay v·ªÅ ƒë√∫ng v·ªã tr√≠ ban ƒë·∫ßu (h∆∞·ªõng l√™n)
  Serial.println("üéØ ƒêi·ªÅu ch·ªânh v·ªã tr√≠ l·ªó cho ƒÉn...");
  feedServo.write(SERVO_MIN_SPEED); // Quay ch·∫≠m ng∆∞·ª£c l·∫°i
  delay(100);                       // ƒêi·ªÅu ch·ªânh nh·∫π
  
  // B∆∞·ªõc 5: D·ª´ng ho√†n to√†n
  feedServo.write(SERVO_STOP_SPEED);
  delay(200);
  
  // C·∫≠p nh·∫≠t th·ªùi gian cho ƒÉn cu·ªëi ch·ªâ khi l√† AUTO (c·∫£m bi·∫øn)
  if (feedType == "AUTO") {
    lastAutoFeedTime = millis();
  }
  
  // G·ª≠i th√¥ng tin l√™n Blynk (CH·ªà KHI CHO ƒÇN - TI·∫æT KI·ªÜM QUOTA)
  struct tm timeinfo;
  if(getLocalTime(&timeinfo)){
    char timeString[64];
    strftime(timeString, sizeof(timeString), "%H:%M:%S %d/%m", &timeinfo);
    Blynk.virtualWrite(V_LAST_FEED, String(timeString) + " - " + feedType);
    Serial.println("üì° G·ª≠i th√¥ng tin cho ƒÉn l√™n Blynk");
  }
  
  Serial.println("‚úÖ HO√ÄN TH√ÄNH CHO ƒÇN!");
  Serial.println("üîÑ L·ªó cho ƒÉn ƒë√£ quay v·ªÅ v·ªã tr√≠ t·ªëi ∆∞u");
  Serial.println("==========================================");
}

// ======= H√ÄM CHO ƒÇN V·ªöI L∆Ø·ª¢NG T√ôY CH·ªàNH =======
void feedFishCustom(int customDuration, int customSpeed, String feedType = "CUSTOM") {
  Serial.println("üêü CHO ƒÇN T√ôY CH·ªàNH - " + feedType);
  Serial.printf("‚öôÔ∏è T·ªëc ƒë·ªô: %d, Th·ªùi gian: %dms\n", customSpeed, customDuration);
  
  feedServo.write(SERVO_STOP_SPEED);
  delay(200);
  
  feedServo.write(customSpeed);
  delay(customDuration);
  
  feedServo.write(SERVO_STOP_SPEED);
  delay(100);
  
  // ƒêi·ªÅu ch·ªânh v·ªã tr√≠
  feedServo.write(SERVO_MIN_SPEED);
  delay(50);
  feedServo.write(SERVO_STOP_SPEED);
  
  Serial.println("‚úÖ Ho√†n th√†nh cho ƒÉn t√πy ch·ªânh!");
}

// ======= H√ÄM KI·ªÇM TRA C√ì TH·ªÇ CHO ƒÇN T·ª∞ ƒê·ªòNG KH√îNG (CH·ªà CHO C·∫¢M BI·∫æN) =======
bool canAutoFeed() {
  return (millis() - lastAutoFeedTime) >= SENSOR_FEED_DELAY;
}

// ======= H√ÄM KI·ªÇM TRA V√Ä TH·ª∞C HI·ªÜN H·∫∏N GI·ªú =======
void checkScheduledFeeding() {
  if (!scheduleMode) return;
  
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)) return;
  
  int currentHour = timeinfo.tm_hour;
  int currentMinute = timeinfo.tm_min;
  int currentDay = timeinfo.tm_mday;
  
  // Reset c·ªù cho ƒÉn khi sang ng√†y m·ªõi
  if (currentDay != lastFeedDay) {
    morningFed = false;
    eveningFed = false;
    lastFeedDay = currentDay;
    Serial.println("üåÖ Ng√†y m·ªõi - Reset tr·∫°ng th√°i cho ƒÉn");
  }
  
  // Ki·ªÉm tra gi·ªù cho ƒÉn s√°ng
  if (!morningFed && currentHour == morningHour && currentMinute == morningMinute) {
    Serial.println("‚è∞ ƒê·∫æN GI·ªú CHO ƒÇN S√ÅNG!");
    feedFish("MORNING");
    morningFed = true;
  }
  
  // Ki·ªÉm tra gi·ªù cho ƒÉn chi·ªÅu
  if (!eveningFed && currentHour == eveningHour && currentMinute == eveningMinute) {
    Serial.println("‚è∞ ƒê·∫æN GI·ªú CHO ƒÇN CHI·ªÄU!");
    feedFish("EVENING");
    eveningFed = true;
  }
}

// ======= H√ÄM C·∫¨P NH·∫¨T TH·ªúI GIAN L√äN BLYNK (TI·∫æT KI·ªÜM QUOTA) =======
void smartUpdateTimeDisplay() {
  unsigned long currentTime = millis();
  
  // Ch·ªâ c·∫≠p nh·∫≠t th·ªùi gian m·ªói 5 ph√∫t thay v√¨ m·ªói ph√∫t
  if (currentTime - lastTimeUpdate >= TIME_UPDATE_INTERVAL) {
    struct tm timeinfo;
    if(getLocalTime(&timeinfo)){
      char timeString[64];
      strftime(timeString, sizeof(timeString), "%H:%M:%S\n%d/%m/%Y", &timeinfo);
      Blynk.virtualWrite(V_CURRENT_TIME, timeString);
      lastTimeUpdate = currentTime;
      Serial.println("üì° C·∫≠p nh·∫≠t th·ªùi gian l√™n Blynk");
    }
  }
}

// ======= H√ÄM G·ª¨I D·ªÆ LI·ªÜU KH·ªûI T·∫†O CH·ªà M·ªòT L·∫¶N =======
void sendInitialData() {
  if (!blynkDataSent && Blynk.connected()) {
    // Ch·ªâ g·ª≠i m·ªôt l·∫ßn khi k·∫øt n·ªëi th√†nh c√¥ng
    Blynk.virtualWrite(V_AUTO_MODE, autoMode);
    Blynk.virtualWrite(V_SCHEDULE_MODE, scheduleMode);
    Blynk.virtualWrite(V_FEED_AMOUNT, feedDuration);
    Blynk.virtualWrite(V_SERVO_SPEED, servoSpeed);
    
    blynkDataSent = true;
    Serial.println("üì° ƒê√£ g·ª≠i d·ªØ li·ªáu kh·ªüi t·∫°o l√™n Blynk");
  }
}

// ======= BLYNK: CH·∫æ ƒê·ªò C·∫¢NH B√ÅO T·ª∞ ƒê·ªòNG =======
BLYNK_WRITE(V_AUTO_MODE) {
  autoMode = param.asInt();
  Serial.print("üîÑ Ch·∫ø ƒë·ªô c·∫£m bi·∫øn t·ª± ƒë·ªông: ");
  Serial.println(autoMode ? "B·∫¨T" : "T·∫ÆT");
}

// ======= BLYNK: CH·∫æ ƒê·ªò H·∫∏N GI·ªú =======
BLYNK_WRITE(V_SCHEDULE_MODE) {
  scheduleMode = param.asInt();
  Serial.print("‚è∞ Ch·∫ø ƒë·ªô h·∫πn gi·ªù: ");
  Serial.println(scheduleMode ? "B·∫¨T" : "T·∫ÆT");
}

// ======= BLYNK: CHO ƒÇN TH·ª¶ C√îNG (KH√îNG DELAY) =======
BLYNK_WRITE(V_MANUAL_FEED) {
  int buttonState = param.asInt();
  
  if (buttonState == 1) {
    Serial.println("üì± NH·∫¨N L·ªÜNH CHO ƒÇN TH·ª¶ C√îNG T·ª™ BLYNK");
    feedFish("MANUAL"); // Cho ƒÉn ngay l·∫≠p t·ª©c, kh√¥ng c·∫ßn delay
  }
}

// ======= BLYNK: ƒêI·ªÄU CH·ªàNH L∆Ø·ª¢NG TH·ª®C ƒÇN =======
BLYNK_WRITE(V_FEED_AMOUNT) {
  feedDuration = param.asInt();
  feedDuration = constrain(feedDuration, FEED_TIME_MIN, FEED_TIME_MAX);
  Serial.printf("üçΩÔ∏è ƒêi·ªÅu ch·ªânh th·ªùi gian cho ƒÉn: %dms\n", feedDuration);
}

// ======= BLYNK: ƒêI·ªÄU CH·ªàNH T·ªêC ƒê·ªò SERVO =======
BLYNK_WRITE(V_SERVO_SPEED) {
  servoSpeed = param.asInt();
  servoSpeed = constrain(servoSpeed, SERVO_MIN_SPEED, SERVO_MAX_SPEED);
  Serial.printf("‚ö° ƒêi·ªÅu ch·ªânh t·ªëc ƒë·ªô servo: %d\n", servoSpeed);
}

// ======= BLYNK: C·∫¨P NH·∫¨T GI·ªú CHO ƒÇN S√ÅNG =======
BLYNK_WRITE(V_MORNING_TIME) {
  TimeInputParam t(param);
  if (t.hasStartTime()) {
    morningHour = t.getStartHour();
    morningMinute = t.getStartMinute();
    Serial.printf("üåÖ ƒê√£ c·∫≠p nh·∫≠t gi·ªù cho ƒÉn s√°ng: %02d:%02d\n", morningHour, morningMinute);
  }
}

// ======= BLYNK: C·∫¨P NH·∫¨T GI·ªú CHO ƒÇN CHI·ªÄU =======
BLYNK_WRITE(V_EVENING_TIME) {
  TimeInputParam t(param);
  if (t.hasStartTime()) {
    eveningHour = t.getStartHour();
    eveningMinute = t.getStartMinute();
    Serial.printf("üåÜ ƒê√£ c·∫≠p nh·∫≠t gi·ªù cho ƒÉn chi·ªÅu: %02d:%02d\n", eveningHour, eveningMinute);
  }
}

// ======= THI·∫æT L·∫¨P BAN ƒê·∫¶U =======
void setup() {
  Serial.begin(115200);
  Serial.println("üöÄ KH·ªûI ƒê·ªòNG H·ªÜ TH·ªêNG CHO C√Å ƒÇN TH√îNG MINH V3.1 - TI·∫æT KI·ªÜM BLYNK QUOTA");
  Serial.println("=======================================================================");
  
  // C·∫•u h√¨nh ch√¢n HC-SR04
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  // Kh·ªüi t·∫°o servo v√† ƒë·∫∑t v·ªÅ v·ªã tr√≠ d·ª´ng
  feedServo.attach(SERVO_PIN);
  feedServo.write(SERVO_STOP_SPEED);
  delay(1000); // Ch·ªù servo ·ªïn ƒë·ªãnh
  Serial.println("‚úÖ Servo ƒë√£ s·∫µn s√†ng (d·ª´ng ·ªü v·ªã tr√≠ 90¬∞)");
  
  // K·∫øt n·ªëi WiFi v√† Blynk
  Serial.print("üì∂ ƒêang k·∫øt n·ªëi WiFi: ");
  Serial.println(ssid);
  
  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);
  
  Serial.println("‚úÖ K·∫øt n·ªëi WiFi th√†nh c√¥ng!");
  
  // C·∫•u h√¨nh th·ªùi gian NTP
  configTime(GMT_OFFSET_SEC, DAYLIGHT_OFFSET_SEC, ntpServer);
  Serial.println("‚è∞ ƒêang ƒë·ªìng b·ªô th·ªùi gian...");
  
  // Ch·ªù ƒë·ªìng b·ªô th·ªùi gian
  struct tm timeinfo;
  int retryCount = 0;
  while(!getLocalTime(&timeinfo) && retryCount < 10) {
    delay(1000);
    retryCount++;
    Serial.print(".");
  }
  
  if (retryCount < 10) {
    Serial.println("\n‚úÖ ƒê·ªìng b·ªô th·ªùi gian th√†nh c√¥ng!");
    char timeString[64];
    strftime(timeString, sizeof(timeString), "%A, %B %d %Y %H:%M:%S", &timeinfo);
    Serial.println("üïê Th·ªùi gian hi·ªán t·∫°i: " + String(timeString));
  } else {
    Serial.println("\n‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªìng b·ªô th·ªùi gian!");
  }
  
  Serial.println("üì± Blynk ƒë√£ s·∫µn s√†ng");
  Serial.println("=======================================================================");
  
  Serial.println("üéØ H·ªÜ TH·ªêNG ƒê√É S·∫¥N S√ÄNG HO·∫†T ƒê·ªòNG!");
  Serial.println("üìè Ch·∫ø ƒë·ªô c·∫£m bi·∫øn: Kho·∫£ng c√°ch k√≠ch ho·∫°t < 5cm");
  Serial.println("‚è∞ Ch·∫ø ƒë·ªô h·∫πn gi·ªù: 8:00 s√°ng & 17:00 chi·ªÅu");
  Serial.println("üì± Cho ƒÉn th·ªß c√¥ng: Kh√¥ng c√≥ delay");
  Serial.printf("‚öôÔ∏è Servo t·ªëi ∆∞u: T·ªëc ƒë·ªô %d, Th·ªùi gian %dms\n", servoSpeed, feedDuration);
  Serial.println("üéõÔ∏è C√≥ th·ªÉ ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô v√† l∆∞·ª£ng th·ª©c ƒÉn qua app");
  Serial.println("üí° T·ªêI ∆ØU BLYNK QUOTA:");
  Serial.println("   - Kho·∫£ng c√°ch: G·ª≠i m·ªói 5s, ch·ªâ khi thay ƒë·ªïi >2cm");
  Serial.println("   - Th·ªùi gian: C·∫≠p nh·∫≠t m·ªói 5 ph√∫t");
  Serial.println("   - D·ªØ li·ªáu kh·ªüi t·∫°o: Ch·ªâ g·ª≠i 1 l·∫ßn");
  Serial.println("=======================================================================");
  
  // Test servo ho·∫°t ƒë·ªông
  Serial.println("üß™ Test servo...");
  feedServo.write(SERVO_DEFAULT_SPEED);
  delay(500);
  feedServo.write(SERVO_STOP_SPEED);
  Serial.println("‚úÖ Test servo ho√†n t·∫•t!");
}

// ======= V√íNG L·∫∂P CH√çNH =======
void loop() {
  Blynk.run();
  
  // G·ª≠i d·ªØ li·ªáu kh·ªüi t·∫°o ch·ªâ m·ªôt l·∫ßn
  sendInitialData();
  
  // C·∫≠p nh·∫≠t th·ªùi gian l√™n Blynk (m·ªói 5 ph√∫t)
  smartUpdateTimeDisplay();
  
  // Ki·ªÉm tra h·∫πn gi·ªù cho ƒÉn
  checkScheduledFeeding();
  
  // ƒêo kho·∫£ng c√°ch
  float distance = measureDistance();
  
  // G·ª≠i kho·∫£ng c√°ch th√¥ng minh (ti·∫øt ki·ªám quota)
  smartSendDistance(distance);
  
  // In kho·∫£ng c√°ch ra Serial (m·ªói 2 gi√¢y)
  static unsigned long lastPrintTime = 0;
  if (millis() - lastPrintTime >= 2000) {
    Serial.print("üìè Kho·∫£ng c√°ch: ");
    if (distance < 999) {
      Serial.print(distance, 1);
      Serial.println(" cm");
    } else {
      Serial.println("Kh√¥ng ph√°t hi·ªán");
    }
    lastPrintTime = millis();
  }
  
  // LOGIC CHO ƒÇN T·ª∞ ƒê·ªòNG THEO C·∫¢M BI·∫æN (ch·ªâ khi b·∫≠t ch·∫ø ƒë·ªô c·∫£m bi·∫øn)
  if (autoMode && distance < TRIGGER_DISTANCE && distance > 0) {
    if (canAutoFeed()) {
      Serial.println("üéØ PH√ÅT HI·ªÜN C√Å TRONG PH·∫†M VI!");
      Serial.print("üìè Kho·∫£ng c√°ch: ");
      Serial.print(distance, 1);
      Serial.println(" cm");
      feedFish("AUTO");
    } else {
      unsigned long remainingTime = (SENSOR_FEED_DELAY - (millis() - lastAutoFeedTime)) / 1000;
      static unsigned long lastWarningTime = 0;
      
      if (millis() - lastWarningTime >= 3000) {
        Serial.print("‚ö†Ô∏è C√° ƒë√£ t·ªõi nh∆∞ng ch∆∞a th·ªÉ cho ƒÉn! C√≤n l·∫°i: ");
        Serial.print(remainingTime);
        Serial.println(" gi√¢y");
        lastWarningTime = millis();
      }
    }
  }
  
  delay(100);
}